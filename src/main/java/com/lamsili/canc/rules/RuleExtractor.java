package com.lamsili.canc.rules;

import com.lamsili.canc.fca.concept.FormalConcept;
import com.lamsili.canc.fca.context.NominalContext;

import java.util.*;

/**
 * Class responsible for extracting classification rules from
 * formal concepts generated by conceptual analysis.
 */
public class RuleExtractor {

    /**
     * Extracts rules from a list of formal concepts and a nominal context.
     * For each concept, the method finds the majority class in its extent
     * and generates a rule.
     *
     * @param concepts List of formal concepts
     * @param context Nominal context containing instances and their attributes
     * @param useDisjointRules If true, generates disjoint rules (one per attribute)
     * @return List of extracted rules
     */
    public List<Rule> extractRules(List<FormalConcept> concepts, NominalContext context, boolean useDisjointRules) {
        List<Rule> rules = new ArrayList<>();
        int totalInstances = context.getNumInstances();

        for (FormalConcept concept : concepts) {
            // Find the majority class in the extent
            String majorityClass = findMajorityClass(concept.getExtent(), context);

            // If no clear majority class, skip
            if (majorityClass == null) {
                continue;
            }

            // Get the intent (attribute-value pairs) of the concept
            Set<Map.Entry<String, String>> intentPairs = concept.getIntent();

            if (useDisjointRules && !intentPairs.isEmpty()) {
                // Mode règles disjointes : une règle par attribut
                for (Map.Entry<String, String> pair : intentPairs) {
                    Map<String, String> singleCondition = new HashMap<>();
                    singleCondition.put(pair.getKey(), pair.getValue());

                    // Calculate the support (size of the extent)
                    int support = concept.getExtentSize();

                    // Create the rule with initial weight 1.0 and support
                    Rule rule = new Rule(singleCondition, majorityClass, 1.0, support);

                    // Calculer et définir le poids comme le ratio de couverture (|extent| / |S|)
                    double weight = support / (double) totalInstances;
                    rule.setWeight(weight);

                    rules.add(rule);
                }
            } else {
                // Mode normal : une règle avec toutes les conditions
                Map<String, String> conditions = new HashMap<>();
                for (Map.Entry<String, String> pair : intentPairs) {
                    conditions.put(pair.getKey(), pair.getValue());
                }

                // Calculate the support (size of the extent)
                int support = concept.getExtentSize();

                // Create the rule with initial weight 1.0 and support
                Rule rule = new Rule(conditions, majorityClass, 1.0, support);

                // Calculer et définir le poids comme le ratio de couverture (|extent| / |S|)
                double weight = support / (double) totalInstances;
                rule.setWeight(weight);

                rules.add(rule);
            }
        }

        return rules;
    }

    /**
     * Extracts rules from a list of formal concepts and a nominal context.
     * This is a compatibility method that uses the default setting for disjoint rules (false).
     *
     * @param concepts List of formal concepts
     * @param context Nominal context containing instances and their attributes
     * @return List of extracted rules
     */
    public List<Rule> extractRules(List<FormalConcept> concepts, NominalContext context) {
        return extractRules(concepts, context, false);
    }

    /**
     * Extrait les règles pour chaque concept individuellement.
     * Retourne une map liant chaque concept à la liste de ses règles extraites.
     *
     * @param concepts Liste des concepts formels
     * @param context  Contexte nominal
     * @param useDisjointRules Mode disjoint ou non
     * @return Map de FormalConcept vers liste de Rule
     */
    public Map<FormalConcept, List<Rule>> extractRulesByConcept(List<FormalConcept> concepts, NominalContext context, boolean useDisjointRules) {
        Map<FormalConcept, List<Rule>> conceptRules = new LinkedHashMap<>();
        int totalInstances = context.getNumInstances();
        for (FormalConcept concept : concepts) {
            List<Rule> rules = new ArrayList<>();
            String majorityClass = findMajorityClass(concept.getExtent(), context);
            if (majorityClass == null) continue;
            Set<Map.Entry<String, String>> intentPairs = concept.getIntent();
            if (useDisjointRules && !intentPairs.isEmpty()) {
                for (Map.Entry<String, String> pair : intentPairs) {
                    Map<String, String> singleCondition = new HashMap<>();
                    singleCondition.put(pair.getKey(), pair.getValue());
                    int support = concept.getExtentSize();
                    Rule rule = new Rule(singleCondition, majorityClass, 1.0, support);
                    double weight = support / (double) totalInstances;
                    rule.setWeight(weight);
                    rules.add(rule);
                }
            } else {
                Map<String, String> conditions = new HashMap<>();
                for (Map.Entry<String, String> pair : intentPairs) {
                    conditions.put(pair.getKey(), pair.getValue());
                }
                int support = concept.getExtentSize();
                Rule rule = new Rule(conditions, majorityClass, 1.0, support);
                double weight = support / (double) totalInstances;
                rule.setWeight(weight);
                rules.add(rule);
            }
            conceptRules.put(concept, rules);
        }
        return conceptRules;
    }

    /**
     * Surcharge : mode non-disjoint par défaut.
     */
    public Map<FormalConcept, List<Rule>> extractRulesByConcept(List<FormalConcept> concepts, NominalContext context) {
        return extractRulesByConcept(concepts, context, false);
    }

    /**
     * Finds the majority class in a set of instance indices.
     *
     * @param instanceIndices Set of instance indices
     * @param context Nominal context
     * @return The majority class, or null if there is no clear majority
     */
    private String findMajorityClass(Set<Integer> instanceIndices, NominalContext context) {
        Map<String, Integer> classCount = new HashMap<>();

        // Count occurrences of each class
        for (Integer instanceIdx : instanceIndices) {
            String instanceClass = context.getInstanceClass(instanceIdx);
            classCount.put(instanceClass, classCount.getOrDefault(instanceClass, 0) + 1);
        }

        // Find the class with the maximum count
        String majorityClass = null;
        int maxCount = 0;
        boolean tie = false;

        for (Map.Entry<String, Integer> entry : classCount.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                majorityClass = entry.getKey();
                tie = false;
            } else if (entry.getValue() == maxCount) {
                tie = true;
            }
        }

        // In case of a tie, don't return a majority class
        if (tie) {
            return null;
        }
        return majorityClass;
    }
}
