package com.lamsili.canc.rules;

import com.lamsili.canc.fca.concept.FormalConcept;
import com.lamsili.canc.fca.context.NominalContext;

import java.util.*;

/**
 * Class responsible for extracting classification rules from
 * formal concepts generated by conceptual analysis.
 */
public class RuleExtractor {

    /**
     * Extracts rules from a list of formal concepts and a nominal context.
     * For each concept, the method finds the majority class in its extent
     * and generates a rule.
     *
     * @param concepts List of formal concepts
     * @param context Nominal context containing instances and their attributes
     * @return List of extracted rules
     */
    public List<Rule> extractRules(List<FormalConcept> concepts, NominalContext context) {
        List<Rule> rules = new ArrayList<>();
        int totalInstances = context.getNumInstances();

        for (FormalConcept concept : concepts) {
            // Find the majority class in the extent
            String majorityClass = findMajorityClass(concept.getExtent(), context);

            // If no clear majority class, skip
            if (majorityClass == null) {
                continue;
            }

            // Convert the intent to conditions for the rule
            Map<String, String> conditions = new HashMap<>();
            for (Map.Entry<String, String> pair : concept.getIntent()) {
                conditions.put(pair.getKey(), pair.getValue());
            }

            // Calculate the support (size of the extent)
            int support = concept.getExtentSize();

            // Create the rule with initial weight 1.0 and support
            Rule rule = new Rule(conditions, majorityClass, 1.0, support);

            // Calculer et d√©finir le poids comme le ratio de couverture (|extent| / |S|)
            double weight = support / (double) totalInstances;
            rule.setWeight(weight);

            rules.add(rule);
        }

        return rules;
    }

    /**
     * Finds the majority class in a set of instance indices.
     *
     * @param instanceIndices Set of instance indices
     * @param context Nominal context
     * @return The majority class, or null if there is no clear majority
     */
    private String findMajorityClass(Set<Integer> instanceIndices, NominalContext context) {
        Map<String, Integer> classCount = new HashMap<>();

        // Count occurrences of each class
        for (Integer instanceIdx : instanceIndices) {
            String instanceClass = context.getInstanceClass(instanceIdx);
            classCount.put(instanceClass, classCount.getOrDefault(instanceClass, 0) + 1);
        }

        // Find the class with the maximum count
        String majorityClass = null;
        int maxCount = 0;
        boolean tie = false;

        for (Map.Entry<String, Integer> entry : classCount.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                majorityClass = entry.getKey();
                tie = false;
            } else if (entry.getValue() == maxCount) {
                tie = true;
            }
        }

        // In case of a tie, don't return a majority class
        if (tie) {
            return null;
        }
        return majorityClass;
    }
}
