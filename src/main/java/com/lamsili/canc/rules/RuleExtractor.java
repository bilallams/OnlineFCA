package com.lamsili.canc.rules;

import com.lamsili.canc.fca.concept.FormalConcept;
import com.lamsili.canc.fca.context.NominalContext;

import java.io.Serializable;
import java.util.*;
import com.yahoo.labs.samoa.instances.Instance;

/**
 * Class responsible for extracting classification rules from
 * formal concepts generated by conceptual analysis.
 */
public class RuleExtractor implements Serializable {
    // Ajouter un serialVersionUID pour la stabilité de la sérialisation
    private static final long serialVersionUID = 1L;

    /**
     * Extracts rules from a list of formal concepts and a nominal context.
     * For each concept, the method finds the majority class in its extent
     * and generates a rule.
     *
     * @param concepts List of formal concepts
     * @param context Nominal context containing instances and their attributes
     * @param useDisjointRules If true, generates disjoint rules (one per attribute)
     * @return List of extracted rules
     */
    public List<Rule> extractRules(List<FormalConcept> concepts, NominalContext context, boolean useDisjointRules) {
        List<Rule> rules = new ArrayList<>();
        int totalInstances = context.getNumInstances();

        for (FormalConcept concept : concepts) {
            // Find the majority class in the extent
            String majorityClass = findMajorityClass(concept.getExtent(), context);

            // If no clear majority class, skip
            if (majorityClass == null) {
                continue;
            }

            // Get the intent (attribute-value pairs) of the concept
            Set<Map.Entry<String, String>> intentPairs = concept.getIntent();

            if (useDisjointRules && !intentPairs.isEmpty()) {
                // Mode règles disjointes : une règle par attribut
                for (Map.Entry<String, String> pair : intentPairs) {
                    Map<String, String> singleCondition = new HashMap<>();
                    singleCondition.put(pair.getKey(), pair.getValue());

                    // Calculate the support (size of the extent)
                    int support = concept.getExtentSize();

                    // Create the rule with initial weight 1.0 and support
                    Rule rule = new Rule(singleCondition, majorityClass, 1.0, support);

                    // Calculer et définir le poids comme le ratio de couverture (|extent| / |S|)
                    double weight = support / (double) totalInstances;
                    rule.setWeight(weight);

                    rules.add(rule);
                }
            } else {
                // Mode normal : une règle avec toutes les conditions
                Map<String, String> conditions = new HashMap<>();
                for (Map.Entry<String, String> pair : intentPairs) {
                    conditions.put(pair.getKey(), pair.getValue());
                }

                // Calculate the support (size of the extent)
                int support = concept.getExtentSize();

                // Create the rule with initial weight 1.0 and support
                Rule rule = new Rule(conditions, majorityClass, 1.0, support);

                // Calculer et définir le poids comme le ratio de couverture (|extent| / |S|)
                double weight = support / (double) totalInstances;
                rule.setWeight(weight);

                rules.add(rule);
            }
        }

        // Calculer les métriques pour les règles extraites
        calculateRuleMetrics(rules, context);

        return rules;
    }

    /**
     * Calcule les métriques de support, confiance et poids pour toutes les règles
     *
     * @param rules Liste des règles à évaluer
     * @param context Contexte nominal contenant les instances
     */
    public void calculateRuleMetrics(List<Rule> rules, NominalContext context) {
        if (rules == null || rules.isEmpty()) return;

        int totalInstances = context.getNumInstances();
        Rule.setTotalInstances(totalInstances);

        for (Rule rule : rules) {
            // Ne recalculer plus l'occurrence de la prémisse : elle correspond à la taille de l'extent du concept d'origine
            int premiseOccurrence = rule.getPremiseOccurrence(); // |X|
            int ruleOccurrence = 0; // |X,C|
            if (totalInstances > 0) {
                // On parcourt uniquement pour compter les vrais positifs (|X,C|)
                for (int i = 0; i < totalInstances; i++) {
                    Instance instance = context.getInstance(i);
                    String actualClass = context.getInstanceClass(i);
                    if (rule.appliesTo(instance) && actualClass != null && actualClass.equals(rule.getPredictedClass())) {
                        ruleOccurrence++;
                    }
                }
            }
            // Mettre à jour uniquement ce qui dépend de |X,C|
            rule.setTruePositiveCountWithoutRecalculation(ruleOccurrence);
            double support = totalInstances > 0 ? (double) ruleOccurrence / totalInstances : 0.0;
            rule.setSupportRuleWithoutRecalculation(support);
            double confidence = premiseOccurrence > 0 ? (double) ruleOccurrence / premiseOccurrence : 0.0;
            rule.setConfidence(confidence);
            double weight = support * confidence;
            rule.setWeight(weight);
        }
    }

    /**
     * Met à jour les métriques uniquement pour les règles applicables.
     * Cette optimisation évite de recalculer les métriques pour toutes les règles.
     *
     * @param applicableRules Les règles qui s'appliquent à l'instance correctement classifiée
     * @param context Le contexte nominal contenant les instances
     */
    public void updateRuleMetrics(List<Rule> applicableRules, NominalContext context) {
        if (applicableRules == null || applicableRules.isEmpty()) {
            return;
        }
        int totalInstances = context.getNumInstances();
        Rule.setTotalInstances(totalInstances);
        for (Rule rule : applicableRules) {
            int premiseOccurrence = rule.getPremiseOccurrence(); // conservé
            int ruleOccurrence = 0; // |X,C|
            for (int i = 0; i < totalInstances; i++) {
                Instance instance = context.getInstance(i);
                String actualClass = context.getInstanceClass(i);
                if (rule.appliesTo(instance) && actualClass != null && actualClass.equals(rule.getPredictedClass())) {
                    ruleOccurrence++;
                }
            }
            rule.setTruePositiveCountWithoutRecalculation(ruleOccurrence);
            double support = totalInstances > 0 ? (double) ruleOccurrence / totalInstances : 0.0;
            rule.setSupportRuleWithoutRecalculation(support);
            double confidence = premiseOccurrence > 0 ? (double) ruleOccurrence / premiseOccurrence : 0.0;
            rule.setConfidence(confidence);
            double weight = support * confidence;
            rule.setWeight(weight);
        }
    }

    /**
     * Met à jour les concepts existants avec une nouvelle instance et recalcule les règles associées.
     * Nouvelle implémentation généralisée:
     * 1. Ajoute l'instance à tout concept dont l'intention est incluse dans les (attr,val) de l'instance
     * 2. Recalcule la classe majoritaire des concepts modifiés
     * 3. Met à jour les classes prédites des règles couvertes par ces concepts
     * 4. Recalcule les métriques pour toutes les règles (car impact indirect possible)
     *
     * @param concepts Tous les concepts formels existants (historique complet)
     * @param instance Nouvelle instance
     * @param instanceIndex Index de l'instance dans le contexte
     * @param allRules Liste complète des règles (et non seulement les applicables)
     * @param context Contexte nominal
     * @return nombre de concepts réellement mis à jour
     */
    public int updateConceptsWithNewInstance(List<FormalConcept> concepts, Instance instance, int instanceIndex,
                                            List<Rule> allRules, NominalContext context) {
        // Appel rétrocompatible sans collecte des éléments modifiés
        return updateConceptsWithNewInstance(concepts, instance, instanceIndex, allRules, context, null, null);
    }

    /** Nouvelle version avec listes de sortie pour concepts et règles modifiés */
    public int updateConceptsWithNewInstance(List<FormalConcept> concepts, Instance instance, int instanceIndex,
                                            List<Rule> allRules, NominalContext context,
                                            List<FormalConcept> modifiedConceptsOut,
                                            List<Rule> modifiedRulesOut) {
        if (concepts == null || concepts.isEmpty()) {
            System.out.println("[MAJ CONCEPTS] Aucune liste de concepts fournie.");
            return 0;
        }
        Map<String, String> instanceAttrValues = new HashMap<>();
        for (int a = 0; a < instance.numAttributes(); a++) {
            if (a == instance.classIndex() || !instance.attribute(a).isNominal()) continue;
            instanceAttrValues.put(instance.attribute(a).name(), instance.attribute(a).value((int) instance.value(a)));
        }
        int updatedCount = 0;
        List<FormalConcept> updatedConcepts = new ArrayList<>();
        for (FormalConcept concept : concepts) {
            boolean intentIncluded = true;
            for (Map.Entry<String,String> intentPair : concept.getIntent()) {
                String v = instanceAttrValues.get(intentPair.getKey());
                if (v == null || !v.equals(intentPair.getValue())) { intentIncluded = false; break; }
            }
            if (intentIncluded && !concept.getExtent().contains(instanceIndex)) {
                concept.addToExtent(instanceIndex);
                updatedConcepts.add(concept);
                updatedCount++;
            }
        }
        Set<Rule> affectedRules = new HashSet<>();
        if (!updatedConcepts.isEmpty() && allRules != null && !allRules.isEmpty()) {
            Map<FormalConcept,String> majorityCache = new HashMap<>();
            for (FormalConcept c : updatedConcepts) {
                majorityCache.put(c, findMajorityClass(c.getExtent(), context));
            }
            for (Rule rule : allRules) {
                Map<String,String> conds = rule.getConditions();
                for (FormalConcept c : updatedConcepts) {
                    boolean covered = true;
                    for (Map.Entry<String,String> cond : conds.entrySet()) {
                        boolean found = false;
                        for (Map.Entry<String,String> intentPair : c.getIntent()) {
                            if (intentPair.getKey().equals(cond.getKey()) && intentPair.getValue().equals(cond.getValue())) { found = true; break; }
                        }
                        if (!found) { covered = false; break; }
                    }
                    if (covered) {
                        String newMaj = majorityCache.get(c);
                        if (newMaj != null && !newMaj.equals(rule.getPredictedClass())) {
                            rule.setPredictedClass(newMaj);
                        }
                        // Mise à jour de l'occurrence (|X|) si le concept correspond exactement aux conditions de la règle
                        if (c.getIntent().size() == conds.size()) {
                            rule.setPremiseOccurrenceWithoutRecalculation(c.getExtentSize());
                        }
                        affectedRules.add(rule);
                        break;
                    }
                }
            }
        }
        if (!affectedRules.isEmpty()) {
            updateRuleMetrics(new ArrayList<>(affectedRules), context);
        }
        if (modifiedConceptsOut != null) {
            modifiedConceptsOut.addAll(updatedConcepts);
        }
        if (modifiedRulesOut != null) {
            modifiedRulesOut.addAll(affectedRules);
        }
        return updatedCount;
    }

    /**
     * Finds the majority class in a set of instance indices.
     *
     * @param instanceIndices Set of instance indices
     * @param context Nominal context
     * @return The majority class, or null if there is no clear majority
     */
    private String findMajorityClass(Set<Integer> instanceIndices, NominalContext context) {
        Map<String, Integer> classCount = new HashMap<>();
        String firstMaxClass = null;  // Pour stocker la première classe avec le maximum d'occurrences

        // Count occurrences of each class
        for (Integer instanceIdx : instanceIndices) {
            String instanceClass = context.getInstanceClass(instanceIdx);
            classCount.put(instanceClass, classCount.getOrDefault(instanceClass, 0) + 1);
        }

        // Find the class with the maximum count
        String majorityClass = null;
        int maxCount = 0;
        boolean tie = false;

        for (Map.Entry<String, Integer> entry : classCount.entrySet()) {
            if (entry.getValue() > maxCount) {
                maxCount = entry.getValue();
                majorityClass = entry.getKey();
                firstMaxClass = entry.getKey(); // Enregistrer la première classe avec le max
                tie = false;
            } else if (entry.getValue() == maxCount) {
                tie = true;
            }
        }

        // En cas d'égalité, retourner la première classe avec le maximum d'occurrences
        if (tie) {
            return firstMaxClass;
        }
        return majorityClass;
    }
}
